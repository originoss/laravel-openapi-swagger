# Laravel OpenAPI Annotation Library

A Laravel package for generating OpenAPI (formerly Swagger) specifications from your code using PHP 8 attributes. This library allows you to keep your API documentation close to your code, ensuring it stays up-to-date with your API's implementation.

## Core Concepts

- **Attribute-Driven**: OpenAPI specifications are generated by parsing PHP 8 attributes (`#[Attribute]`) directly from your controllers and Eloquent models (or other PHP classes).
- **Code-Centric**: Keep your API documentation within your codebase.
- **No Database Introspection**: The library does **not** connect to your database to infer schema information. Model schemas are derived solely from explicitly annotated `#[Property]` attributes on your model classes.
- **Explicit is Better**: Only model properties that are explicitly annotated with `#[Property]` will be included in the generated OpenAPI specification.
- **Laravel Friendly**: Designed to integrate smoothly with Laravel projects, including Artisan commands for spec generation.
- **Model::class Support**: References to models can use the `Model::class` syntax for better IDE support and refactoring capabilities.
- **Enum Support**: Full support for PHP enums in your API documentation.

## Installation

1.  **Require the package via Composer:**
    ```bash
    composer require origin-oss/laravel-openapi
    ```
    *(Note: Replace `origin-oss/laravel-openapi` with the actual package name once registered on Packagist.)*

2.  **Publish the configuration file (optional):**
    If you need to customize the default settings, you can publish the configuration file:
    ```bash
    php artisan vendor:publish --tag=openapi-config
    ```
    This will create a `config/openapi.php` file in your project.

*(Further sections like Basic Usage, Advanced Usage, Artisan Commands, and Configuration will be added in subsequent steps.)*

## Basic Usage

### Annotating Controllers

To document your API endpoints, you'll primarily use attributes on your controller methods.

- `#[LaravelOpenApi\Attributes\Operation(...)]`: Describes a single API operation (endpoint). You can specify `summary`, `description`, `tags`, `operationId`, etc.
- `#[LaravelOpenApi\Attributes\Parameter(...)]`: Describes a parameter for the operation (e.g., path, query, header). You define its `name`, `in` (location), `description`, `required` status, and `schema`.
- `#[LaravelOpenApi\Attributes\RequestBody(...)]`: Describes the request body for operations like POST, PUT, PATCH. You can specify its `description`, `required` status, and the `content` (often a reference to a model schema or a direct schema definition).
- `#[LaravelOpenApi\Attributes\Response(...)]`: Describes a possible HTTP response for the operation. You define the HTTP `status` code, `description`, and `content` (often a reference to a model schema or a specific response structure). You can have multiple `#[Response]` attributes for different status codes.

**Example: A simple UserController method**

```php
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use LaravelOpenApi\Attributes as OA; // Recommended alias

class UserController extends Controller
{
    /**
     * List all users.
     */
    #[OA\Operation(
        tags: ['Users'],
        summary: 'List Users',
        description: 'Retrieves a paginated list of users.'
    )]
    #[OA\Parameter(
        name: 'page',
        in: 'query',
        description: 'The page number for pagination.',
        required: false,
        schema: ['type' => 'integer', 'example' => 1]
    )]
    #[OA\Response(
        status: 200,
        description: 'A list of users.',
        content: [
            'application/json' => ['schema' => ['type' => 'array', 'items' => ['$ref' => '#/components/schemas/User']]]
        ]
    )]
    public function index(Request $request)
    {
        // Your controller logic here
        return response()->json(['message' => 'List of users placeholder']); // Placeholder
    }

    /**
     * Get a specific user by ID.
     */
    #[OA\Operation(
        tags: ['Users'],
        summary: 'Get User by ID',
        description: 'Retrieves a specific user by their ID.'
    )]
    #[OA\Parameter(
        name: 'id',
        in: 'path',
        description: 'ID of the user to retrieve.',
        required: true,
        schema: ['type' => 'integer', 'format' => 'int64', 'example' => 101]
    )]
    #[OA\Response(
        status: 200,
        description: 'The requested user.',
        content: [
            'application/json' => ['schema' => ['$ref' => '#/components/schemas/User']]
        ]
    )]
    #[OA\Response(
        status: 404,
        description: 'User not found.'
    )]
    public function show(int $id)
    {
        // Your controller logic here
        return response()->json(['message' => "User {$id} placeholder"]); // Placeholder
    }
}
```

### Annotating Models

Models (typically Eloquent models, but can be any PHP class) are annotated to define their structure for request/response bodies.

- `#[LaravelOpenApi\Attributes\Schema(...)]`: Used at the class level to define the overall schema for the model. You can set a `title`, `description`, and a list of `required` properties.
- `#[LaravelOpenApi\Attributes\Property(...)]`: Used on individual PHP properties to describe them. You specify `type`, `format`, `description`, `example`, `nullable`, `enum`, and other validation constraints. **Only properties explicitly annotated with `#[Property]` will be included in the OpenAPI specification.**

### Using Enums

You can use PHP enums in your API documentation to define valid values for properties:

```php
<?php

namespace App\Enums;

enum UserStatus: string
{
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    case SUSPENDED = 'suspended';
}
```

Then in your model or controller attributes:

```php
#[OA\Property(
    property: 'status',
    type: 'string',
    description: 'User status',
    enum: ['active', 'inactive', 'suspended']
)]
public string $status;
```

### Using Model::class Syntax for References

You can use the `Model::class` syntax for references to models, which provides better IDE support and makes refactoring easier:

```php
// In a controller method
#[OA\Response(
    status: 200,
    description: 'The requested user.',
    content: [
        new OA\MediaType(mediaType: 'application/json', schema: new OA\Schema(ref: User::class))
    ]
)]

// For array items
#[OA\Property(
    property: 'users',
    type: 'array',
    items: new OA\Items(ref: User::class)
)]
public array $users;
```

**Example: A simple User model**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use LaravelOpenApi\Attributes as OA;

#[OA\Schema(
    title: 'User',
    description: 'Represents an application user.',
    required: ['id', 'name', 'email']
)]
class User extends Model
{
    #[OA\Property(
        description: 'Unique identifier for the user.',
        type: 'integer',
        format: 'int64',
        example: 1,
        nullable: false
    )]
    public int $id;

    #[OA\Property(
        description: 'Name of the user.',
        type: 'string',
        example: 'John Doe',
        nullable: false
    )]
    public string $name;

    #[OA\Property(
        description: 'Email address of the user.',
        type: 'string',
        format: 'email',
        example: 'john.doe@example.com',
        nullable: false
    )]
    public string $email;

    #[OA\Property(
        description: 'Timestamp when the user email was verified.',
        type: 'string',
        format: 'date-time',
        nullable: true // This field can be null
    )]
    public ?string $email_verified_at; // PHP 7.4+ typed property

    #[OA\Property(
        description: 'Indicates if the user is an administrator.',
        type: 'boolean',
        example: false,
        default: false // Default value if not provided
    )]
    public bool $is_admin = false;

    // This property will NOT be included in the OpenAPI spec
    // because it does not have an #[OA\Property] attribute.
    public string $some_internal_detail;

    // Timestamps (created_at, updated_at)
    // If you want these in your API, you should also annotate them with #[OA\Property]
    #[OA\Property(type: 'string', format: 'date-time', nullable: true)]
    public ?string $created_at;

    #[OA\Property(type: 'string', format: 'date-time', nullable: true)]
    public ?string $updated_at;
}
```

## Generating the Specification

Once you have annotated your controllers and models, you can generate the OpenAPI specification using the following Artisan command:

```bash
php artisan openapi:generate
```

By default, this will create an `openapi.json` file in your project's `public` directory. You can customize the output path, format, and other generation options through command-line parameters or in the `config/openapi.php` file.

### Output Formats (JSON/YAML)

The package supports both JSON and YAML formats for your OpenAPI specification. Each format has its advantages:

- **JSON**: More compact, better performance, widely supported by all tools
- **YAML**: More human-readable, supports comments, easier to maintain manually

#### Generating YAML Format

By default, the `openapi:generate` command outputs in JSON format. To generate in YAML format:

```bash
php artisan openapi:generate --format=yaml
```

This will create an `openapi.yaml` file in your project's `public` directory.

#### YAML Requirements

To use YAML format, you need to install the `symfony/yaml` package:

```bash
composer require symfony/yaml
```

#### Customizing Output Path

You can specify a custom output path:

```bash
php artisan openapi:generate --output=docs/api-spec --format=yaml
```

The output filename will automatically use the correct extension (e.g., `.json` or `.yaml`) based on the specified format.

## Viewing API Documentation with Swagger UI

This library includes a built-in Swagger UI to render your OpenAPI specification. The UI now supports both JSON and YAML formats with an easy-to-use format selector.

### Key Features

- **Format Switching**: Toggle between JSON and YAML formats directly in the UI
- **Persistent Format Selection**: Your format choice is saved in the URL hash, so it persists across page refreshes
- **Responsive Design**: Works well on both desktop and mobile devices
- **Latest Swagger UI**: Uses the latest version of Swagger UI for the best experience

### Accessing the UI

By default, you can access the Swagger UI at the `/api-docs` route in your application.

### Configuration Options

The Swagger UI can be extensively configured through the `ui` section in your `config/openapi.php` file:

```php
'ui' => [
    // Enable or disable the UI route
    'enabled' => env('OPENAPI_UI_ENABLED', true),
    
    // Path for the Swagger UI page
    'route' => env('OPENAPI_UI_ROUTE', '/api-docs'),
    
    // Route name for the UI page
    'route_name' => env('OPENAPI_UI_ROUTE_NAME', 'openapi.ui'),
    
    // Title for the HTML page
    'title' => env('OPENAPI_UI_TITLE', 'OpenAPI Documentation UI'),
    
    // Default format to display (json or yaml)
    'default_format' => env('OPENAPI_UI_DEFAULT_FORMAT', 'json'),
    
    // Route name for the JSON spec
    'spec_route_name_json' => env('OPENAPI_UI_SPEC_ROUTE_NAME_JSON', 'openapi.json'),
    
    // Additional Swagger UI configuration options
    'config' => [
        'docExpansion' => env('OPENAPI_UI_DOC_EXPANSION', 'list'),
        'deepLinking' => true,
        'persistAuthorization' => true,
        // Add any other Swagger UI options here
    ],
],
```

### Customizing the Swagger UI View

If you need to customize the appearance or behavior of Swagger UI beyond the configuration options, you can publish its Blade view:

```bash
php artisan vendor:publish --tag=openapi-views
```

This will copy the `swagger-ui.blade.php` view to `resources/views/vendor/openapi/`. You can then modify this file as needed to:

- Update Swagger UI versions
- Change the layout or styling
- Add custom JavaScript functionality
- Integrate with your application's theme
- Add authentication for the documentation

### URL Parameters

The Swagger UI supports the following URL parameters:

- `#format=yaml` - Switch to YAML format
- `#format=json` - Switch to JSON format (default)

For example: `https://your-app.com/api-docs#format=yaml`

# Credits
- Boosttrapped by [Jules](https://jules.google)
- Enhanced by [Claude](https://claude.ai)
- Orchestrated by [Steve](https://github.com/stevenosse)